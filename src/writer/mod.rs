// Copyright 2016 Masaki Hara
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use std::io;

#[cfg(feature = "bigint")]
use num::bigint::{BigUint, BigInt};

use super::*;

/// Constructs DER-encoded data as `Vec<u8>`.
///
/// This function uses the loan pattern: `callback` is called back with
/// a `DERWriter`, to which the ASN.1 data is written.
///
/// # Examples
///
/// ```
/// use yasna;
/// let der = yasna::construct_der(|writer| {
///     writer.write_sequence(|writer| {
///         try!(writer.write_i64(10));
///         try!(writer.write_bool(true));
///         return Ok(());
///     })
/// }).unwrap();
/// assert_eq!(der, vec![48, 6, 2, 1, 10, 1, 1, 255]);
/// ```
///
/// # Errors
///
/// This function just carries errors generated by `callback`.
///
pub fn construct_der<F>(mut callback: F) -> io::Result<Vec<u8>>
        where F: FnMut(&mut DERWriter) -> io::Result<()> {
    let mut writer = DERWriter {
        buf: Vec::new(),
    };
    try!(callback(&mut writer));
    return Ok(writer.buf);
}

/// A writer object that has an internal buffer storing DER-encoded data.
///
/// This object is only created by `construct_der` function.
#[derive(Debug)]
pub struct DERWriter {
    buf: Vec<u8>,
}

impl DERWriter {
    /// Writes BER identifier (tag + primitive/constructed) octets.
    fn write_identifier(&mut self, tag: Tag, pc: PC) -> io::Result<()> {
        let classid = tag.tag_class as u8;
        let pcid = pc as u8;
        if tag.tag_number < 31 {
            self.buf.push(
                (classid << 6) | (pcid << 5) | (tag.tag_number as u8));
            return Ok(());
        }
        self.buf.push((classid << 6) | (pcid << 5) | 31);
        let mut shiftnum = 63; // ceil(64 / 7) * 7 - 7
        while (tag.tag_number >> shiftnum) == 0 {
            shiftnum -= 7;
        }
        while shiftnum > 0 {
            self.buf.push(128 | (((tag.tag_number >> shiftnum) & 127) as u8));
            shiftnum -= 7;
        }
        self.buf.push((tag.tag_number & 127) as u8);
        return Ok(());
    }

    /// Writes BER length octets.
    fn write_length(&mut self, length: usize) -> io::Result<()> {
        let length = length as u64;
        if length < 128 {
            self.buf.push(length as u8);
            return Ok(());
        }
        let mut shiftnum = 56; // ceil(64 / 8) * 8 - 8
        while (length >> shiftnum) == 0 {
            shiftnum -= 8;
        }
        self.buf.push(128 | ((shiftnum / 8 + 1) as u8));
        loop {
            self.buf.push((length >> shiftnum) as u8);
            if shiftnum == 0 {
                break;
            }
            shiftnum -= 8;
        }
        return Ok(());
    }

    /// Deals with unknown length procedures.
    /// This function first marks the current position and
    /// allocates 3 bytes. Then it calls back `callback`.
    /// It then calculates the length and moves the written data
    /// to the actual position. Finally, it writes the length.
    fn with_length<T, F>(&mut self, mut callback: F) -> io::Result<T>
        where F: FnMut(&mut Self) -> io::Result<T> {
        let expected_length_length = 3;
        for _ in 0..3 {
            self.buf.push(255);
        }
        let start_pos = self.buf.len();
        let result = try!(callback(self));
        let length = (self.buf.len() - start_pos) as u64;
        let length_length;
        let mut shiftnum = 56; // ceil(64 / 8) * 8 - 8
        if length < 128 {
            length_length = 1;
        } else {
            while (length >> shiftnum) == 0 {
                shiftnum -= 8;
            }
            length_length = shiftnum / 8 + 2;
        }
        let new_start_pos;
        if length_length < expected_length_length {
            let diff = expected_length_length - length_length;
            new_start_pos = start_pos - diff;
            self.buf.drain(new_start_pos .. start_pos);
        } else if length_length > expected_length_length {
            let diff = length_length - expected_length_length;
            new_start_pos = start_pos + diff;
            for _ in 0..diff { self.buf.insert(start_pos, 0); }
        } else {
            new_start_pos = start_pos;
        }
        let mut idx = new_start_pos - length_length;
        if length < 128 {
            self.buf[idx] = length as u8;
        } else {
            self.buf[idx] = 128 | ((shiftnum / 8 + 1) as u8);
            idx += 1;
            loop {
                self.buf[idx] = (length >> shiftnum) as u8;
                idx += 1;
                if shiftnum == 0 {
                    break;
                }
                shiftnum -= 8;
            }
        }
        return Ok(result);
    }

    /// Writes `bool` as an ASN.1 BOOLEAN value.
    ///
    /// # Examples
    ///
    /// ```
    /// use yasna;
    /// let der = yasna::construct_der(|writer| {
    ///     writer.write_bool(true)
    /// }).unwrap();
    /// assert_eq!(der, vec![1, 1, 255]);
    /// ```
    pub fn write_bool(&mut self, val: bool) -> io::Result<()> {
        try!(self.write_identifier(TAG_BOOLEAN, PC::Primitive));
        try!(self.write_length(1));
        self.buf.push(if val { 255 } else { 0 });
        return Ok(());
    }

    /// Writes `i64` as an ASN.1 INTEGER value.
    ///
    /// # Examples
    ///
    /// ```
    /// use yasna;
    /// let der = yasna::construct_der(|writer| {
    ///     writer.write_i64(1234567890)
    /// }).unwrap();
    /// assert_eq!(der, vec![2, 4, 73, 150, 2, 210]);
    /// ```
    pub fn write_i64(&mut self, val: i64) -> io::Result<()> {
        let mut shiftnum = 56;
        while shiftnum > 0 &&
                (val >> (shiftnum-1) == 0 || val >> (shiftnum-1) == -1) {
            shiftnum -= 8;
        }
        try!(self.write_identifier(TAG_INTEGER, PC::Primitive));
        try!(self.write_length(shiftnum / 8 + 1));
        loop {
            self.buf.push((val >> shiftnum) as u8);
            if shiftnum == 0 {
                break;
            }
            shiftnum -= 8;
        }
        return Ok(());
    }

    /// Writes `u64` as an ASN.1 INTEGER value.
    pub fn write_u64(&mut self, val: u64) -> io::Result<()> {
        let mut shiftnum = 64;
        while shiftnum > 0 && val >> (shiftnum-1) == 0 {
            shiftnum -= 8;
        }
        try!(self.write_identifier(TAG_INTEGER, PC::Primitive));
        try!(self.write_length(shiftnum / 8 + 1));
        if shiftnum == 64 {
            self.buf.push(0);
            shiftnum -= 8;
        }
        loop {
            self.buf.push((val >> shiftnum) as u8);
            if shiftnum == 0 {
                break;
            }
            shiftnum -= 8;
        }
        return Ok(());
    }

    /// Writes `i32` as an ASN.1 INTEGER value.
    pub fn write_i32(&mut self, val: i32) -> io::Result<()> {
        self.write_i64(val as i64)
    }

    /// Writes `u32` as an ASN.1 INTEGER value.
    pub fn write_u32(&mut self, val: u32) -> io::Result<()> {
        self.write_i64(val as i64)
    }

    /// Writes `i16` as an ASN.1 INTEGER value.
    pub fn write_i16(&mut self, val: i16) -> io::Result<()> {
        self.write_i64(val as i64)
    }

    /// Writes `u16` as an ASN.1 INTEGER value.
    pub fn write_u16(&mut self, val: u16) -> io::Result<()> {
        self.write_i64(val as i64)
    }

    /// Writes `i8` as an ASN.1 INTEGER value.
    pub fn write_i8(&mut self, val: i8) -> io::Result<()> {
        self.write_i64(val as i64)
    }

    /// Writes `u8` as an ASN.1 INTEGER value.
    pub fn write_u8(&mut self, val: u8) -> io::Result<()> {
        self.write_i64(val as i64)
    }

    #[cfg(feature = "bigint")]
    /// Writes `BigInt` as an ASN.1 INTEGER value.
    ///
    /// # Examples
    ///
    /// ```
    /// # extern crate num;
    /// # extern crate yasna;
    /// # fn main() {
    /// use yasna;
    /// use num::bigint::BigInt;
    /// let der = yasna::construct_der(|writer| {
    ///     writer.write_bigint(
    ///         &BigInt::parse_bytes(b"1234567890", 10).unwrap())
    /// }).unwrap();
    /// assert_eq!(der, vec![2, 4, 73, 150, 2, 210]);
    /// # }
    /// ```
    pub fn write_bigint(&mut self, val: &BigInt) -> io::Result<()> {
        use num::bigint::Sign;
        try!(self.write_identifier(TAG_INTEGER, PC::Primitive));
        let (sign, mut bytes) = val.to_bytes_le();
        match sign {
            Sign::NoSign => {
                try!(self.write_length(1));
                self.buf.push(0);
                return Ok(());
            },
            Sign::Plus => {
                let byteslen = bytes.len();
                debug_assert!(bytes[byteslen-1] != 0);
                if bytes[byteslen-1] >= 128 {
                    try!(self.write_length(byteslen+1));
                    self.buf.push(0);
                } else {
                    try!(self.write_length(byteslen));
                }
                bytes.reverse();
                self.buf.extend_from_slice(&bytes);
                return Ok(());
            },
            Sign::Minus => {
                let byteslen = bytes.len();
                debug_assert!(bytes[byteslen-1] != 0);
                let mut carry : usize = 1;
                for b in bytes.iter_mut() {
                    let bval = 255 - (*b as usize);
                    *b = (bval + carry) as u8;
                    carry = (bval + carry) >> 8;
                }
                if bytes[byteslen-1] < 128 {
                    try!(self.write_length(byteslen+1));
                    self.buf.push(255);
                } else {
                    try!(self.write_length(byteslen));
                }
                bytes.reverse();
                self.buf.extend_from_slice(&bytes);
                return Ok(());
            }
        };
    }

    #[cfg(feature = "bigint")]
    /// Writes `BigUint` as an ASN.1 INTEGER value.
    ///
    /// # Examples
    ///
    /// ```
    /// # extern crate num;
    /// # extern crate yasna;
    /// # fn main() {
    /// use yasna;
    /// use num::bigint::BigUint;
    /// let der = yasna::construct_der(|writer| {
    ///     writer.write_biguint(
    ///         &BigUint::parse_bytes(b"1234567890", 10).unwrap())
    /// }).unwrap();
    /// assert_eq!(der, vec![2, 4, 73, 150, 2, 210]);
    /// # }
    /// ```
    pub fn write_biguint(&mut self, val: &BigUint) -> io::Result<()> {
        try!(self.write_identifier(TAG_INTEGER, PC::Primitive));
        let mut bytes = val.to_bytes_le();
        if &bytes == &[0] {
            try!(self.write_length(1));
            self.buf.push(0);
            return Ok(());
        }
        let byteslen = bytes.len();
        debug_assert!(bytes[byteslen-1] != 0);
        if bytes[byteslen-1] >= 128 {
            try!(self.write_length(byteslen+1));
            self.buf.push(0);
        } else {
            try!(self.write_length(byteslen));
        }
        bytes.reverse();
        self.buf.extend_from_slice(&bytes);
        return Ok(());
    }

    /// Writes ASN.1 SEQUENCE.
    ///
    /// This function uses the loan pattern: `callback` is called back with
    /// a `DERWriter`, to which the contents of the SEQUENCE is written.
    ///
    /// # Examples
    ///
    /// ```
    /// use yasna;
    /// let der = yasna::construct_der(|writer| {
    ///     writer.write_sequence(|writer| {
    ///         try!(writer.write_i64(10));
    ///         try!(writer.write_bool(true));
    ///         return Ok(());
    ///     })
    /// }).unwrap();
    /// assert_eq!(der, vec![48, 6, 2, 1, 10, 1, 1, 255]);
    /// ```
    pub fn write_sequence<T, F>(&mut self, callback: F) -> io::Result<T>
        where F: FnMut(&mut Self) -> io::Result<T> {
        try!(self.write_identifier(TAG_SEQUENCE, PC::Constructed));
        return self.with_length(callback);
    }
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]
enum PC {
    Primitive = 0, Constructed = 1,
}

#[cfg(test)]
mod tests;
